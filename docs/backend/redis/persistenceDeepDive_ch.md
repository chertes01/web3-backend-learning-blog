# Redis 持久化机制学习笔记

Redis 是一个内存数据库，其数据主要存储在 RAM 中以实现快速访问。为了防止服务器宕机或故障时数据丢失，Redis 提供了持久化机制将数据保存到磁盘。

Redis 提供三种主要的持久化方法：
1.  **RDB (Redis Database) 快照**
2.  **AOF (Append Only File) 日志**
3.  **混合持久化 (RDB-AOF)**

---

## 1. RDB (Redis Database) 快照方式

RDB 是一种持久化方式，它在特定的时间点创建内存中数据的快照，并将其写入二进制文件（默认文件名为 `dump.rdb`）。

### 1.1 RDB 触发机制

RDB 持久化过程分为 **手动触发** 和 **自动触发**。

#### 手动触发

| 命令 | 描述 | 注意事项 |
| :--- | :--- | :--- |
| `SAVE` | 阻塞当前 Redis 服务器进程，直到 RDB 过程完成。 | 如果内存数据较多，会导致长时间阻塞，影响其他命令的使用，**不建议在生产环境使用**。 |
| `BGSAVE` | Redis 进程执行 `fork` 指令创建子进程，由子进程实现 RDB 持久化。 | **推荐使用**。 |

#### 自动触发

自动触发是通过配置 `save m n` 实现的，表示在 $m$ 秒内如果数据集存在 $n$ 次修改时，会自动触发 `BGSAVE` 命令。

| 配置示例 | 解释 |
| :--- | :--- |
| `save 900 1` | 900 秒内如果超过 1 个 Key 被修改，则发起快照保存。 |
| `save 300 10` | 300 秒内如果超过 10 个 Key 被修改，则发起快照保存。 |
| `save 60 10000`| 60 秒内如果超过 10,000 个 Key 被修改，则发起快照保存。|

### 1.2 RDB 流程图 (BGSAVE)

```
        +---------------+ 
        |  BGSAVE 命令  | 
        +---------------+ 
                | 
                V 
        +---------------+ 
        |    父进程     | 
        +---------------+ 
                | 
        /--------------------------\
       | 检查：有其他子进程正在执行? | 
        \---------------------------/ 
                | 
        +-------+-------+ 
        |       |       | 
      [ 是 ]  [ 否 ]    | 
        |       |       | 
        V       V       | 
    [ 直接返回 ] |   `fork()` 
                |       | 
                +-------+--------------------------+ 
                        |                          | 
                        V                          V 
                +-----------------+        +------------------+ 
                | 子进程：         |        | 父进程：          | 
                | 生成 RDB 文件    |        | 响应其他命令      | 
                +-----------------+        +------------------+ 
                        |                          | 
                        V                          | 
                +-----------------------+          | 
                | 子进程：发送完成信号  | <--------+ 
                +-----------------------+ 
```
**流程解释**:
1.  发出 `bgsave` 命令。
2.  父进程检查是否有其他子进程正在执行（如 AOF 重写或另一个 RDB）。如果是，则直接返回。
3.  父进程执行 `fork` 创建一个子进程。
4.  父进程继续响应其他客户端命令。
5.  子进程负责生成 RDB 文件。
6.  完成后，子进程向父进程发送信号通知完成。

### 1.3 RDB 优缺点

| 方面 | 优点 | 缺点 |
| :--- | :--- | :--- |
| **文件** | RDB 快照文件是紧凑压缩的二进制文件，非常适用于备份、全量复制等场景。 | RDB 无法做到实时/秒级持久化，因此可能会丢失上一次快照之后的数据。 |
| **性能** | Redis 加载 RDB 恢复数据远远快于 AOF 方式。 | 每次 `BGSAVE` 时都需要 `fork` 子进程，频繁执行有时间成本，且可能消耗资源。 |
| **兼容性**| | RDB 快照文件不同版本格式可能不一样，容易引起兼容问题。 |

---

## 2. AOF (Append Only File) 日志方式

AOF 以独立日志的方式记录服务器收到的每一次写命令，并追加到 AOF 文件末尾。重启时，Redis 会重新执行 AOF 文件中的命令来恢复数据。

> Redis 默认不开启 AOF，需要手动配置 `appendonly yes`。

### 2.1 AOF 工作流程

```
+----------------+|  客户端写命令  |+----------------+|       | 1. append       V+-----------------+| AOF 缓冲 (内存) |+-----------------|       | 2. sync (同步策略)       V+-----------------+   <---- 3. rewrite (后台压缩) ----+| AOF 文件 (磁盘) |+-----------------+       ^       | 4. load (数据恢复)       |+-----------------+|  服务器重启   |+-----------------+ 
```
1.  **Append**: 所有写命令被追加到 AOF 缓冲区。
2.  **Sync**: 根据同步策略，缓冲区内容被写入磁盘上的 AOF 文件。
3.  **Rewrite**: 当 AOF 文件过大时，Redis 会在后台进行重写，压缩文件体积。
4.  **Load**: Redis 重启时，加载并重新执行 AOF 文件中的命令来恢复数据。

### 2.2 AOF 文件同步策略

该策略决定了 AOF 缓冲何时写入磁盘，用于平衡性能和数据安全性。

| 策略 (`appendfsync`) | 解释 | 数据安全性 vs. 性能 |
| :--- | :--- | :--- |
| `always` | 收到命令就立即写入磁盘。 | 效率最慢，但能保证完全的持久化（数据丢失为 0）。 |
| `everysec` | 每秒写入磁盘一次。 | 在性能和持久化方面做了很好的折中（最多丢失 1 秒数据）。**推荐默认**。 |
| `no` | 完全依赖操作系统来刷新缓冲（通常同步周期约为 30 秒）。 | 性能最快，但持久化保证最弱。 |

### 2.3 AOF 重写机制 (BGREWRITEAOF)

由于 AOF 记录了每一个写命令，文件会持续增大。AOF 重写会创建一个新的、更小的 AOF 文件，其中只包含恢复当前数据集所需的最小命令集。

- **触发方式**:
  - **自动**: 当 AOF 文件超过一定大小和增长百分比时。
  - **手动**: 执行 `BGREWRITEAOF` 命令。
- **工作原理**: 类似于 `BGSAVE`，它也使用 `fork` 创建子进程，以避免阻塞主线程。

### 2.4 AOF 优缺点

| 方面 | 优点 | 缺点 |
| :--- | :--- | :--- |
| **安全** | AOF 数据安全性更高，配置得当，最多损失 1 秒的数据。 | 对于相同数据量，AOF 文件体积通常大于 RDB 文件。 |
| **恢复** | 不小心执行 `FLUSHALL` 时，可通过编辑 AOF 文件来恢复（删除最后一个命令即可）。 | 数据持久化性能上，AOF 比 RDB 慢，因为需要重新执行命令。 |
| **完整性**| AOF 是增量日志文件，损坏可能性较低。即使出现问题，`redis-check-aof` 工具也能轻松修复。 | |

---

## 3. RDB-AOF 混合持久化 (Redis 4.0+)

混合持久化结合了 RDB 和 AOF 的优点。当触发 AOF 重写时，Redis 会：
1.  将当前内存数据以 **RDB 格式** 写入新的 AOF 文件的开头。
2.  将重写过程中产生的增量写命令以 **AOF 格式** 追加到文件末尾。

- **优点**:
  - **RDB 部分**: 保证 Redis 重启时的加载速度。
  - **AOF 部分**: 保证数据的高可靠性，降低数据丢失风险。

这种模式是 Redis 4.0 之后推出的，是目前推荐的持久化方式。

---

## 4. Redis 启动数据加载流程

Redis 启动时，会根据配置和文件的存在性来确定加载哪个持久化文件。

#### 加载流程 (非混合模式)
```
        +-------------------+ 
        | Redis 服务器启动  | 
        +-------------------+ 
                 | 
                 V 
            /-------------\ 
          | 开启了 AOF?   | 
            \-------------/ 
                 | 
        +--------+--------+ 
        | (yes)  |  (no)  | 
        V        V        V 
    /-------------\   /-------------\ 
  | 存在 AOF 文件?| | 存在 RDB 文件?| 
    \-------------/   \-------------/ 
          |                 | 
    +-----+-----+     +-----+-----+ 
    | (yes)| (no)   | (yes)| (no) 
    V      |        V      V 
+-----------------+ | +-----------------+ +-----------------+ 
| 加载 AOF 文件   | <-+ | 加载 RDB 文件   | | 启动 (空数据库) | 
+-----------------+   +-----------------+ +-----------------+ 
          |                 | 
          V                 V 
      /-------------\ 
    |   加载成功?   | 
      \-------------/ 
             | 
     +-------+-------+ 
     | (yes) | (no)  | 
     V       V       V 
+-----------------+ +-----------------+ 
|   启动成功      | |   启动失败      | 
+-----------------+ +-----------------+ 
```

- **关键规则**: 如果 RDB 和 AOF 文件都存在，**Redis 会优先加载 AOF 文件**，因为它能保证更高的数据完整性。

#### 加载流程 (混合模式)
如果使用混合持久化，AOF 文件本身就包含 RDB 和 AOF 两部分。Redis 只需加载这一个文件：
1.  首先加载头部的 RDB 部分进行快速恢复。
2.  然后执行末尾的 AOF 命令以同步到最新状态。

---

## 5. 持久化机制选择建议

| 场景 | 建议 | 理由 |
| :--- | :--- | :--- |
| **对数据安全性有非常高的要求** | RDB 和 AOF（或混合持久化）同时启用。 | 最大限度地兼顾快速重启（RDB）和最小数据丢失（AOF）。 |
| **对数据安全性要求不高，能容忍数据丢失** | 单独使用 RDB。 | 侧重于快速重启和备份文件小巧。 |
| **Redis 版本 $\ge$ 4.0** | **RDB-AOF 混合方式**。 | 结合了两者的优点（快速重启和最小数据丢失）。**这是现代推荐的默认配置**。 |

> **不推荐单独使用 AOF**。对于数据库备份、更快重启以及应对 AOF 引擎中可能出现的错误，RDB 是更好的选择。

```