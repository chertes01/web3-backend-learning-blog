# 🚀 Redis 最佳实践：Key 与 Value 的设计哲学

在项目中高效使用 Redis，不仅要掌握命令，更要遵循一套合理的 Key-Value 设计规范。这直接影响到缓存的可读性、维护性、性能和内存占用。

## 1. Value 设计：选择正确的数据结构

Value 的设计本质上是选择合适的 Redis 数据类型 (String, Hash, List, Set, Sorted Set)。

### 1.1 核心决策流程

| 思考点 | 决策 | 推荐类型 |
| :--- | :--- | :--- |
| 是否需要排序？ | 是（如排行榜、时间轴）。 | **Sorted Set (ZSet)** |
| 是否需要排序？ | 否 | *见下一步* |
| Value 是多个值还是单个值？ | 多个值 | *见下一步* |
| 多个值：是否允许重复？ | 允许重复（如消息队列、操作日志）。 | **List** |
| 多个值：是否允许重复？ | 不允许重复（如共同好友、去重统计）。 | **Set** |
| Value 是多个值还是单个值？ | 单个值 | *见下一步* |
| 单个值：是简单值还是对象值？ | 简单值（如计数器、Token）。 | **String** |
| 单个值：是简单值还是对象值？ | 对象值（如用户信息、配置项）。 | **Hash** |

### 1.2 关于序列化与类型转换（Golang 视角）

虽然 Redis 支持多种数据结构，但在实际的 Golang 项目中，有时会采用一种“取巧”的方式：

- **统一序列化为 JSON 字符串**： 将复杂的 Go Struct、Map 或 List 统一序列化成 JSON 格式的字符串。
- **存储为 String 类型**： 所有数据都使用 `SET` 命令存入 Redis。

**优点 (基于 Golang 客户端)：**
- **操作简化**： 客户端代码无需针对不同的 Redis 类型进行大量泛型或类型断言操作。
- **Go 客户端友好**： Golang 的 `go-redis` 库可以直接将 Struct 通过 JSON 序列化（Marshal）为字符串存入，再反序列化（Unmarshal）回 Struct，开发过程非常平滑。

**缺点：**
- **无法利用 Redis 提供的原子操作**： 如果需要修改对象中的单个字段（如更新用户年龄），必须 `GET` 整个 JSON，在应用层修改，再 `SET` 整个 JSON，效率低且无法保证原子性。

**推荐**： 只有当对象只读、或极少更新时，才考虑使用 **String + JSON** 的方式。 否则，应优先使用 **Hash** 结构实现原子性局部更新。

## 2. Key 设计：保证“四性”原则

Redis Key 的设计必须遵循以下四个核心特性，以确保系统的健壮性和可维护性。

### 2.1 唯一性 (Uniqueness)

Key 必须是唯一的，因为缓存相同 Key 会导致后者覆盖前者。

- **保证方式**： 始终将缓存数据的主键（或联合主键）作为 Key 的组成部分。
- **示例**： 缓存员工信息时，使用员工 ID 作为核心标识。

### 2.2 可读性 (Readability)

Key 应该“见名知意”，能够快速判断其对应 Value 的业务含义，便于排查和维护。

- **不可取设计**： 仅使用主键作为 Key (`1`, `2`)。
- **推荐设计**： 添加业务前缀和唯一标识。

**可读性前缀设计规范（推荐）**

| 规范类型 | 格式 | 示例 | 优势 |
| :--- | :--- | :--- | :--- |
| 普通单值 | `业务:主键值` | `employee:id:1` | 简洁明了，适用于 String。 |
| 通用（模块化） | `模块名:逻辑含义:标识符:Value类型` | `employee:auth.permission:id:1:set` | 最推荐，可读性极强，易于分组。 |

**通用玩法各段解析：**
- **业务模块名**： `employee`（表示该 Key 属于员工模块）。
- **业务逻辑含义**： `auth.permission`（可以使用 `.` 分隔，具体表示缓存的是授权权限信息）。
- **其他（唯一标识）**： `id:1`（通常是主键，保证唯一性）。
- **Value 类型**： `set`（指明 Key 对应的 Value 是 Redis Set 结构，方便维护）。

### 2.3 灵活性 (Flexibility)

当单一主键不足以表达业务含义时，需要使用联合主键或将业务关系映射到 Key 结构中。

**场景**： 评论和回复场景，需要定位到特定的帖子下的特定评论。

**设计示例：**
```text
// 帖子 ID 为 1 下，回复 ID 为 A 的评论内容
post:1:reply:A  -> 评论内容

// 某用户 Alice 针对某文章的投票记录
article:vote:123:user:alice -> 1 (投票状态)
```

### 2.4 时效性 (Timeliness)

Redis Key 必须设置合理的过期时间（TTL）。

- **原则**：评估业务场景： 数据的更新频率、实时性要求、最大容忍延迟，来设置合理的 `seconds`。
- **动态设置**： 可以在写入 Key 时，使用 `SETEX` 或 `SET ... EX` 追加过期时间。
- **警示**： 不设置过期时间（永久 Key）的风险极高。 永久 Key 会一直占用内存不释放，数量过多容易导致服务器内存耗尽（OOM），引发宕机。
- **过期策略**： 在设置 TTL 时，需结合 Redis 的键过期策略（如 LRU/LFU/随机驱逐）一起评估。

```redis
// 设置键，并让其在 60 秒后失效
SET user:session:token:abc "user_data" EX 60
```