# Redis 内存淘汰机制详解（Maxmemory Policy）

---

## 1. 引言

Redis 作为内存数据库，为了防止内存无限增长导致系统资源耗尽，通常需要设置内存上限。Redis 通过配置项 `maxmemory <bytes>` 来设置内存上限。

```bash
maxmemory <bytes>
```

- **默认值**：`0`（在 64 位系统上），表示不限制内存，直到耗尽系统所有可用内存。在 32 位系统上，隐式限制为 3GB。

> **最佳实践**：
> 在实际开发中，需要根据 Key 的体量和业务需求，预先评估并合理设置内存上限。

当 Redis 占用的内存达到配置的 `maxmemory` 上限时，如果客户端继续执行写命令（如 `SET`、`INCR` 等），就需要触发 **内存淘汰机制** 来释放空间。

---

## 2. 内存淘汰算法基础

在了解 Redis 的具体淘汰策略之前，先理解几种核心的淘汰算法。

### 2.1 LRU (Least Recently Used) - 最近最少使用

- **含义**：Least Recently Used，最近最少使用。
- **原理**：认为长期不用的数据，再次被访问的概率也很小。因此，该算法会从数据库中删除最长时间没有被访问的数据。
- **侧重维度**：**时间**，即 Key 上一次被访问的时间点。
- **局限性**：无法应对“偶发性”或“周期性”的高频 Key。例如，一个 Key 之前被高频访问，但现在因为某种原因短期内没有使用，LRU 可能会将其淘汰，即使它很快又会被高频使用。

```
                                                                         当前时间
                                                                             |
                                                                             V
<------------------------------------------------------------------------------------------------------------------> 时间轴
|          Akey 使用3次           |           Bkey 使用2次           |           Ckey 使用1次           |
|---------------------------------|----------------------------------|----------------------------------|
            ^
            |
        (最久未访问，优先淘汰)
```

### 2.2 LFU (Least Frequently Used) - 最不经常使用

- **含义**：Least Frequently Used，最不经常使用。
- **原理**：认为应该淘汰一段时间内使用次数最少的数据。这个算法在一定程度上解决了 LRU 的局限性，能够保护那些访问频率高但近期没有使用的数据。
- **侧重维度**：**频次**（使用次数）和 **时间**（衰减周期）。LFU 不仅记录 Key 的访问次数，还会结合时间进行计数衰减，确保访问频率是基于当前时间段的。
- **优势**：更能适应访问模式的变化，对于长期高频访问的 Key 保护性更好。

```
                                                                         当前时间
                                                                             |
                                                                             V
<------------------------------------------------------------------------------------------------------------------> 时间轴
|          Akey 使用3次           |           Bkey 使用2次           |           Ckey 使用1次           |
|---------------------------------|----------------------------------|----------------------------------|
                                                                                                   ^
                                                                                                   |
                                                                                         (频次最低，优先淘汰)
```

### 2.3 TTL (Time To Live) - 过期时间

- **含义**：Time To Live，生存时间。
- **原理**：专门针对设置了过期时间的数据集。当内存不足时，优先淘汰即将过期的数据。

---

## 3. Redis 内存淘汰策略（Maxmemory Policy）

Redis 通过配置 `maxmemory-policy` 来指定具体的内存淘汰策略。Redis 5.0 以后提供了 8 种可选策略：

```bash
maxmemory-policy <policy>
```

策略可以根据 **作用域**（数据集）和 **淘汰算法** 进行划分。

### 3.1 针对已设置过期时间的数据集 (`volatile-`)

这些策略只在设置了 TTL (Time To Live) 的 Key 中进行淘汰。

| 策略名称 | 淘汰算法 | 描述 |
| :--- | :--- | :--- |
| `volatile-lru` | LRU | 在设置了过期时间的数据集中，淘汰最近最少被访问的数据。 |
| `volatile-lfu` | LFU | 在设置了过期时间的数据集中，淘汰一段时间内使用次数最少的数据。 |
| `volatile-ttl` | TTL | 在设置了过期时间的数据集中，淘汰剩余生存时间最短（即将过期）的数据。 |
| `volatile-random`| 随机 | 在设置了过期时间的数据集中，随机选择 Key 进行淘汰。 |

### 3.2 针对所有 Key 的数据集 (`allkeys-`)

这些策略在数据库中的所有 Key 中进行淘汰，无论它们是否设置了过期时间。

| 策略名称 | 淘汰算法 | 描述 |
| :--- | :--- | :--- |
| `allkeys-lru` | LRU | 在所有 Key 中，淘汰最近最少被访问的数据。 |
| `allkeys-lfu` | LFU | 在所有 Key 中，淘汰一段时间内使用次数最少的数据。 |
| `allkeys-random`| 随机 | 在所有 Key 中，随机选择 Key 进行淘汰。 |

### 3.3 不进行淘汰

| 策略名称 | 淘汰算法 | 描述 |
| :--- | :--- | :--- |
| `no-eviction` | N/A | **（默认策略）** 不进行任何淘汰。当内存达到上限时，后续的写操作（如 `SET`）将返回错误，但读操作（如 `GET`）可以继续。此策略可以保证数据不丢失。 |

---

## 4. 推荐与总结

| 场景 | 推荐策略 | 理由 |
| :--- | :--- | :--- |
| **纯缓存系统** | `allkeys-lru` 或 `allkeys-lfu` | 缓存的目的是淘汰不常用的数据。`allkeys-lru` 是最常用的缓存策略，而 `allkeys-lfu` 在热点数据不规则变动时表现更好。 |
| **混合系统（部分 Key 需持久）** | `volatile-lru` 或 `volatile-lfu` | 只有设置了过期时间的 Key 才会被当作缓存淘汰，确保了需要持久保留的数据（未设置 TTL）不会被清除。 |
| **需要保证数据完整性** | `no-eviction` | 避免任何数据丢失，将内存不足的问题交给应用层处理。 |

> **注意**：
> 实际生产中，Redis 的 LRU 和 LFU 算法都是采用 **近似算法** 实现的，而不是精确的。这是为了保证淘汰过程的高效率，避免扫描所有 Key 带来的性能损耗。

---

## 5. 附录：过期 Key 的删除策略

当一个设置了过期时间（TTL）的 Key 到达其过期时间点后，Redis 如何清理它？

Redis 提供了 3 种可能的实现方案，并在实际中采用了其中两种的组合。

#### 三种理论方案

1.  **惰性删除 (Lazy Deletion)**
    - **做法**：当访问某个 Key 时，才去判断它是否已过期。如果过期，就地删除。
    - **优点**：对 CPU 非常友好，只在需要时才进行检查。
    - **缺点**：如果一个 Key 长期不被访问，它会一直占用内存，造成内存浪费。

2.  **定时删除 (Timer-based Deletion)**
    - **做法**：为每个设置了过期时间的 Key 创建一个定时器。当到达过期时间点，定时器立即执行删除操作。
    - **优点**：能保证 Key 被准时删除，有效释放内存。
    - **缺点**：对 CPU 不友好。如果过期 Key 很多，维护大量的定时器会显著增加 CPU 负担。

3.  **定期删除 (Periodic Deletion)**
    - **做法**：每隔一段时间，对数据库进行一次检查，随机扫描一部分 Key 并删除其中的过期 Key。
    - **优点**：通过限制扫描的时长和频率，可以减少对 CPU 的影响。
    - **缺点**：难以在内存和 CPU 之间做到完美平衡。扫描频率低了，过期 Key 清理不及时；频率高了，又会像定时删除一样消耗 CPU。

#### Redis 的选择：惰性删除 + 定期删除

Redis 服务器实际使用的是 **惰性删除** 和 **定期删除** 两种策略的组合。

> 通过配合使用这两种删除策略，Redis 可以很好地在 **合理使用 CPU** 和 **避免浪费内存** 之间取得平衡。
