# 🗂️ MySQL 索引基础学习笔记

---

## 一、索引的优缺点

- **优势**：提高数据检索效率，降低数据库 IO 成本；通过索引列排序，降低排序成本和 CPU 消耗。
- **劣势**：索引占用空间；提高查询效率的同时，降低了表的更新速度（INSERT、UPDATE、DELETE 时效率降低）。

---

## 二、常见索引结构

- **B+Tree 索引**：最常见，绝大多数引擎支持，适合范围查询和排序。
- **Hash 索引**：底层为哈希表，只支持精确匹配，不支持范围查询。
- **R-tree（空间索引）**：主要用于地理空间数据，MyISAM 支持，使用较少。
- **Full-text（全文索引）**：倒排索引，适合文本关键词检索，类似 Lucene/Solr/ES。

---

## 三、各存储引擎索引支持情况

| 索引类型   | InnoDB | MyISAM | Memory  |
|------------|--------|--------|---------|
| B+Tree     | 支持   | 支持   | 支持    |
| Hash       | 不支持 | 不支持 | 支持    |
| R-tree     | 不支持 | 支持   | 不支持  |
| Full-text  | 5.6+支持 | 支持 | 不支持  |

---

## 四、索引结构原理

### 1. 二叉树与红黑树

- 顺序插入易退化为链表，查询性能差。
- 层级深，检索速度慢。

### 2. B-Tree（多路平衡查找树）

- 每个节点存储多个 key 和指针，减少树高度，提高检索效率。
- 非叶子节点和叶子节点都存数据。
- [ 图例 (Legend) ]
​```
- [K(D)]        : 代表一个节点页(Page)。
                  - K 是“键值”(Key)。
                  - (D) 代表与该键值关联的“数据”(Data)或数据指针。
                  - B-树中，数据(D)与键值(K)在所有层级的节点中都成对出现。
- / | \         : 代表“指针”(Pointer)，指向子节点页。

---------------------------------- 层级 1: 根页 (Root Page) ---------------------------------

                                    [ 34(D) ]
                                         |
                            /---------------------------\
                           /                             \

---------------------- 层级 2: 内部页 (Internal Pages) -------------------------

                [ 16(D) ]                         [ 62(D) | 90(D) ]
                     |                                   |
            /----------------\                      /-----|-----\
           /                  \                    /      |      \

---------------------- 层级 3: 叶节点页 (Leaf Pages) -------------------------

     [6(D)|12(D)]      [18(D)|29(D)]      [38(D)|56(D)] [67(D)|87(D)] [94(D)|98(D)]

     (注意：叶节点之间没有互相连接的指针)
​```

### 3. B+Tree

- 非叶子节点只存 key 和指针，所有数据都在叶子节点。
- 叶子节点通过指针形成单向链表，便于范围查询。
- MySQL 在 B+Tree 基础上优化，叶节点间有顺序指针，区间访问性能更高。


| 要点              | 内容                           |
| --------------- | ---------------------------- |
| **页（Page）**     | InnoDB 存储的基本单位，默认 16KB。      |
| **键（Key）**      | 索引用于排序的字段。                   |
| **数据（Data）**    | 叶子节点存储内容，主键索引为整行数据，二级索引为主键值。 |
| **指针（Pointer）** | 页与页、节点与节点的连接纽带，确保树能快速导航。     |
| **非叶子节点**       | 只存 Key + 指针。                 |
| **叶子节点**        | 存 Key + Data + 相邻页指针。        |

---

## 五、B+Tree 结构示意

- 根页、索引页、叶节点页分层组织。
- 叶节点存储所有数据，并通过指针形成链表，便于范围扫描。

​```
- [ ... ]       : 代表一个完整的“页”(Page)或“块”(Block)。
- / | \         : 代表“指针”(Pointer)，从一个索引页指向下一层的页。
- [P| K1 |P| K2|P] : 索引页的内部结构示意。
                  - K1, K2 是“键值”(Key)，用作索引。
                  - P 是“指针”(Pointer)，指向子节点页。
- [K1|D]<->[K2|D] : 叶节点页(数据页)的内部结构示意。
                  - K1, K2 是“键值”(Key)。
                  - D 代表与键值关联的“数据”(Data)。
                  - <-> 代表叶节点页之间的双向指针。

*--------------------------------- 层级 1: 根页 (Root Page) ---------------------------------
                                     (指针 P0) (指针 P1) (指针 P2)
                                        |       |        |
                                      [ 38 | 67 ]
                                            |
                       /--------------------|--------------------\
                      /                     |                      \
                     P0                    P1                     P2

*--------------------- 层级 2: 索引页 (Index Pages) -------------------------

            [ 16 | 29 ]               [ 55 | 58 ]                [ 90 | 94 ]
                  |                         |                          |
         /--------|--------\         /------|-------\          /-------|--------\
        /         |         \       /        |        \        /        |         \

*--------- 层级 3: 叶节点页 (Leaf Pages) - 包含键值(Key)和数据(Data) -----------

[6|D]<->[16|D]<->[29|D]<->[38|D]<->[55|D]<->[58|D]<->[67|D]<->[90|D]<->[94|D]
 ^                                                                         |
 |________________________(所有数据页通过指针形成一个双向链表)_______________________|
 ​```

- 相对于B-Tree区别：
 ①．所有的数据都会出现在叶子节点
 ②．叶子节点形成一个单向链表

 MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。

- 为什么InnoDB存储引擎选择使用B+tree索引结构？
1.相对于二叉树，层级更少，搜索效率高；
2.对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；
相对Hash索引，B+tree支持范围匹配及排序操作；

---

## 六、索引的组成

| 组成部分 | 层级   | 内容           | 存储位置 | 大小         |
|----------|--------|----------------|----------|--------------|
| 页（Page） | 物理层 | 存储多个索引记录 | 磁盘     | 16 KB        |
| 键值（Key） | 逻辑层 | 用于排序和定位   | 记录区   | 几字节~几十字节 |
| 数据（Data） | 逻辑层 | 记录实际值或主键 | 叶节点   | 依字段类型   |
| 指针（Pointer） | 结构层 | 指向页或相邻记录 | 非叶/叶页 | ~6字节      |

- 非叶节点只存 Key+指针，叶节点存 Key+Data+相邻页指针。

---

## 七、索引分类

| 分类     | 含义                       | 特点           | 关键字    |
|----------|----------------------------|----------------|-----------|
| 主键索引 | 针对主键创建，唯一且自动   | 只能有一个     | PRIMARY   |
| 唯一索引 | 保证列值唯一               | 可有多个       | UNIQUE    |
| 常规索引 | 快速定位数据               | 可有多个       |           |
| 全文索引 | 文本关键词检索             | 可有多个       | FULLTEXT  |

---

## 八、InnoDB 索引存储形式

| 分类         | 含义                                         | 特点           |
|--------------|----------------------------------------------|----------------|
| 聚集索引     | 数据与索引存一起，叶节点存整行数据           | 必须有且唯一   |
| 二级索引     | 索引与数据分开，叶节点存主键值               | 可有多个       |

**聚集索引选取规则：**
- 有主键则主键为聚集索引；
- 无主键则第一个唯一索引为聚集索引；
- 都没有则自动生成 rowid 作为隐藏聚集索引。

---

## 九、聚集索引与二级索引结构示意

- **聚集索引**：叶节点存整行数据，索引与数据“聚集”在一起。
- **二级索引**：叶节点存主键值，通过主键值再去聚集索引查找整行数据（回表）。

​```
*=================================================================================
  InnoDB 聚集索引 (Clustered Index) 与 二级索引 (Secondary Index) 结构示意图
*=================================================================================

*--------------------------------- 1. 原始数据表 ---------------------------------
(代表实际存储在磁盘上的数据行)
+----+-------+--------+
| id | name  | gender |
+----+-------+--------+
| 5  | Kit   | 男     |
| 8  | Ruby  | 女     |
| 10 | Arm   | 女     |
| 11 | Rose  | 女     |
...  ...      ...

----------------------- 2. 聚集索引 (Clustered Index) - 基于主键 id -----------------------
# 叶子节点存储了完整的行数据。
                     [     15 | 30      ]
                            |
           /----------------|----------------\
          /                 |                  \
    [ 10 | 12 ]       [ 25 | 27 ]         [ 60 | 80 ]
        |                  |                    |
  /-----|-----\      /-----|-----\        /-----|-----\
...    ...     ...
[5,8] [10,11] [12,14] ...
 |     |       |
(整行) (整行) (整行) ...
(数据) (数据) (数据)


-------------------------- 3. 二级索引 (Secondary Index) - 基于 name 字段 --------------------------
# 叶子节点存储的是对应行的主键值(id)。
                               [      Lee | Rose      ]
                                        |
                   /--------------------|--------------------\
                  /                     |                      \
        [ Geek | Jack ]         [ Lily | Oil ]         [ Ruby | Xint ]
               |                      |                      |
      /--------|--------\      /-------|--------\      /-------|--------\
     /         |         \    /        |         \    /        |         \
["Arm","Dawn"]["Geek","Hero"] ...
     |           |
  [10,15]     [26,27]    ...
​```

1.  **使用聚集索引查询 (如 WHERE id = 25):**
    * 直接在聚集索引树中进行搜索，找到键值为 25 的叶子节点。
    * 从该叶子节点中直接读取完整的行数据 `(25, 'Jack', '男')`。
    * 过程高效，只需一次索引查找。

2.  **使用二级索引查询 (如 WHERE name = 'Jack'):**
    * 先在 `name` 字段的二级索引树中搜索，找到键值为 'Jack' 的叶子节点。
    * 从该叶子节点中读取到存储的主键值 `25`。
    * 拿到主键值 `25` 后，再回到**聚集索引树**中进行一次查找。
    * 在聚集索引中找到键值为 25 的叶子节点，并读取完整的行数据。
    * 这个“先查二级索引，再回聚集索引查数据”的过程，被称为“**回表**”(Index Lookup)。

---

## 十、回表查询流程

1. 用二级索引定位记录，获得主键值。
2. 用主键值回到聚集索引查找完整行数据。
3. 返回最终结果。
​```
==================================================================================
          “回表查询”详解 (以 `select * from user where name = 'Arm'` 为例)
==================================================================================
          [ SQL查询 ]
select * from user where name = 'Arm';
             |
             V
------------------------------------------------------------------------------------
步骤 1: 搜索 name 字段的“二级索引”
------------------------------------------------------------------------------------
# 数据库首先利用“二级索引”来定位 `name = 'Arm'` 的记录。
# 它会从二级索引的根节点 [Lee|Rose] 开始，最终找到包含 'Arm' 的叶节点 ["Arm","Dawn"]。

             ["Arm","Dawn"]  <-- 在二级索引的叶节点中找到 'Arm'
                  |
             [10,15]       <-- 读取与 'Arm' 关联的值，这个值是主键 id = 10
                  |
                  +----------------------------------------------+
                  |            (拿到主键值，准备“回表”)            |
                  V                                              V
------------------------------------------------------------------------------------
步骤 2: “回表”-- 使用上一步获得的主键ID，去搜索“聚集索引”
------------------------------------------------------------------------------------
# 因为二级索引中只有 name 和 id，但查询需要的是 `*` (所有字段，如 gender)，
# 所以数据库必须“回到”聚集索引中去查找完整的行数据。

                [     15 | 30      ]  <-- 从聚集索引的根节点开始，搜索 id = 10
                       |
                 /----------------...
                /
          [ 10 | 12 ]
              |
        /-----|-----\
       /      |      \
     [5,8] [10,11] [12,14]             <-- 在聚集索引的叶节点中找到 id = 10
             |
   (读取完整的行数据)
             |
             V
------------------------------------------------------------------------------------
步骤 3: 返回最终结果
------------------------------------------------------------------------------------
          (10, 'Arm', '女')
​```
## 总结：回表查询（Index Lookup）

回表查询（Index Lookup）是指这样一种查询过程：

1. **先通过二级索引找到匹配的记录，并从中获取到主键ID。**
2. **再使用这个主键ID，回到聚集索引中进行另一次查找。**
3. **最终在聚集索引的叶子节点中，获取到完整的行数据。**

这种查询方式常见于 InnoDB 存储引擎的二级索引查询，能够兼顾索引检索效率和数据完整性，但会增加一次“回表”操作的成本。
---

## 十一、总结

- B+Tree 是 MySQL 索引的主流结构，支持高效范围查询和排序。
- InnoDB 聚集索引存整行数据，二级索引存主键值，涉及“回表”操作。
- 合理设计索引能显著提升查询性能，但会影响写入和占用空间。

---