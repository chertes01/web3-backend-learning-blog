 优势：提高数据检索的效率，降低数据库的IO成本。 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。
 劣势：索引列也是要占用空间的。索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。

 索引结构
 B+Tree索引：最常见的索引类型，大部分引擎都支持B＋树索引
 Hash索引：底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询
 R-tree（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少
 Full-text（全文索引）：是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene,Solr,ES

 索引支持表
 +---------------+--------------------------+----------+----------+
|     索引      |          InnoDB          |  MyISAM  |  Memory  |
+---------------+--------------------------+----------+----------+
| B+tree 索引   | 支持                     | 支持     | 支持     |
| Hash 索引     | 不支持                   | 不支持   | 支持     |
| R-tree 索引   | 不支持                   | 支持     | 不支持   |
| Full-text     | 5.6版本之后支持          | 支持     | 不支持   |
+---------------+--------------------------+----------+----------+

 二叉树
 缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢。
 红黑树：大数据量情况下，层级较深，检索速度慢。

 B-Tree（多路平衡查找树）
 以一颗最大度数（max-degree) 为5(5阶）的b-tree为例（每个节点最多存储4个key,5个指针，树的度数指的是一个节点的子节点个数）

 [ 图例 (Legend) ]
- [K(D)]        : 代表一个节点页(Page)。
                  - K 是“键值”(Key)。
                  - (D) 代表与该键值关联的“数据”(Data)或数据指针。
                  - B-树中，数据(D)与键值(K)在所有层级的节点中都成对出现。
- / | \         : 代表“指针”(Pointer)，指向子节点页。

---------------------------------- 层级 1: 根页 (Root Page) ---------------------------------

                                    [ 34(D) ]
                                         |
                            /---------------------------\
                           /                             \

---------------------- 层级 2: 内部页 (Internal Pages) -------------------------

                [ 16(D) ]                         [ 62(D) | 90(D) ]
                     |                                   |
            /----------------\                      /-----|-----\
           /                  \                    /      |      \

---------------------- 层级 3: 叶节点页 (Leaf Pages) -------------------------

     [6(D)|12(D)]      [18(D)|29(D)]      [38(D)|56(D)] [67(D)|87(D)] [94(D)|98(D)]

     (注意：叶节点之间没有互相连接的指针)

 B+Tree
 以一颗最大度数（max-degree）为4(4阶）的b+tree为例：
 - [ ... ]       : 代表一个完整的“页”(Page)或“块”(Block)。
- / | \         : 代表“指针”(Pointer)，从一个索引页指向下一层的页。
- [P| K1 |P| K2|P] : 索引页的内部结构示意。
                  - K1, K2 是“键值”(Key)，用作索引。
                  - P 是“指针”(Pointer)，指向子节点页。
- [K1|D]<->[K2|D] : 叶节点页(数据页)的内部结构示意。
                  - K1, K2 是“键值”(Key)。
                  - D 代表与键值关联的“数据”(Data)。
                  - <-> 代表叶节点页之间的双向指针。

---------------------------------- 层级 1: 根页 (Root Page) ---------------------------------
                                     (指针 P0) (指针 P1) (指针 P2)
                                        |       |        |
                                      [ 38 | 67 ]
                                            |
                       /--------------------|--------------------\
                      /                     |                      \
                     P0                    P1                     P2

---------------------- 层级 2: 索引页 (Index Pages) -------------------------

            [ 16 | 29 ]               [ 55 | 58 ]                [ 90 | 94 ]
                  |                         |                          |
         /--------|--------\         /------|-------\          /-------|--------\
        /         |         \       /        |        \        /        |         \

---------- 层级 3: 叶节点页 (Leaf Pages) - 包含键值(Key)和数据(Data) -----------

[6|D]<->[16|D]<->[29|D]<->[38|D]<->[55|D]<->[58|D]<->[67|D]<->[90|D]<->[94|D]
 ^                                                                         |
 |________________________(所有数据页通过指针形成一个双向链表)_______________________|

页、键、数据、指针的关系
 | 组成部分        | 层级  | 内容          | 典型存储位置 | 大小       |
| ----------- | --- | ----------- | ------ | -------- |
| 页（Page）     | 物理层 | 存储多个索引记录    | 磁盘     | 16 KB    |
| 键值（Key）     | 逻辑层 | 用于排序和定位     | 记录数据区  | 几字节到几十字节 |
| 数据（Data）    | 逻辑层 | 记录的实际值（或主键） | 叶子节点   | 依字段类型而定  |
| 指针（Pointer） | 结构层 | 指向页或相邻记录    | 非叶页、叶页 | 约 6 字节   |


 | 要点              | 内容                           |
| --------------- | ---------------------------- |
| **页（Page）**     | InnoDB 存储的基本单位，默认 16KB。      |
| **键（Key）**      | 索引用于排序的字段。                   |
| **数据（Data）**    | 叶子节点存储内容，主键索引为整行数据，二级索引为主键值。 |
| **指针（Pointer）** | 页与页、节点与节点的连接纽带，确保树能快速导航。     |
| **非叶子节点**       | 只存 Key + 指针。                 |
| **叶子节点**        | 存 Key + Data + 相邻页指针。        |




 相对于B-Tree区别：
 ①．所有的数据都会出现在叶子节点
 ②．叶子节点形成一个单向链表

 MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。

为什么InnoDB存储引擎选择使用B+tree索引结构？
1.相对于二叉树，层级更少，搜索效率高；
2.对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；
相对Hash索引，B+tree支持范围匹配及排序操作；
高

 索引分类
 +--------------+------------------------------------------------------------+------------------------------+------------+
|     分类     |                            含义                            |             特点             |   关键字   |
+--------------+------------------------------------------------------------+------------------------------+------------+
|   主键索引   | 针对于表中主键创建的索引                                   | 默认自动创建, 只能有一个     | PRIMARY    |
|   唯一索引   | 避免同一个表中某数据列中的值重复                           | 可以有多个                   | UNIQUE     |
|   常规索引   | 快速定位特定数据                                           | 可以有多个                   |            |
|   全文索引   | 全文索引查找的是文本中的关键词, 而不是比较索引中的值       | 可以有多个                   | FULLTEXT   |
+--------------+------------------------------------------------------------+------------------------------+------------+

 在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：
 +--------------------------------+--------------------------------------------------------------------------+--------------------------+
|              分类              |                                   含义                                   |           特点           |
+--------------------------------+--------------------------------------------------------------------------+--------------------------+
|   聚集索引(Clustered Index)    | 将数据存储与索引放到了一块, 索引结构的叶子节点保存了行数据         | 必须有, 而且只有一个     |
|   二级索引(Secondary Index)    | 将数据与索引分开存储, 索引结构的叶子节点关联的是对应的主键         | 可以存在多个             |
+--------------------------------+--------------------------------------------------------------------------+--------------------------+


--- 聚集索引选取规则 ---

> 如果存在主键, 主键索引就是聚集索引。

> 如果不存在主键, 将使用第一个唯一(UNIQUE)索引作为聚集索引。

> 如果表没有主键, 或没有合适的唯一索引, 则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

 ==================================================================================
  InnoDB 聚集索引 (Clustered Index) 与 二级索引 (Secondary Index) 结构示意图
==================================================================================

---------------------------------- 1. 原始数据表 ---------------------------------
(代表实际存储在磁盘上的数据行)
+----+-------+--------+
| id | name  | gender |
+----+-------+--------+
| 5  | Kit   | 男     |
| 8  | Ruby  | 女     |
| 10 | Arm   | 女     |
| 11 | Rose  | 女     |
| 12 | Zoom  | 男     |
| 14 | Tim   | 男     |
| 15 | Dawn  | 男     |
| 21 | Pine  | 男     |
| 25 | Jack  | 男     |
| 26 | Geek  | 男     |
| 27 | Hero  | 男     |
| 28 | Lem   | 男     |
| 30 | Roxy  | 女     |
| 45 | Oil   | 女     |
| 60 | Xint  | 男     |
| 72 | Mina  | 女     |
| 80 | Lee   | 男     |
| 90 | Lily  | 女     |
+----+-------+--------+

----------------------- 2. 聚集索引 (Clustered Index) - 基于主键 id -----------------------
# 特点：叶子节点存储了完整的行数据。索引和数据真正地“聚集”在了一起。

                     [     15 | 30      ]
                            |
           /----------------|----------------\
          /                 |                  \
    [ 10 | 12 ]       [ 25 | 27 ]         [ 60 | 80 ]
        |                  |                    |
  /-----|-----\      /-----|-----\        /-----|-----\
 /      |      \    /      |      \      /      |      \
[5,8] [10,11] [12,14] [15,21] [25,26] [27,28] [30,45] [60,72] [80,90]
 |     |       |       |       |       |       |       |       |
(整行) (整行) (整行) (整行) (整行) (整行) (整行) (整行) (整行)
(数据) (数据) (数据) (数据) (数据) (数据) (数据) (数据) (数据)


-------------------------- 3. 二级索引 (Secondary Index) - 基于 name 字段 --------------------------
# 特点：叶子节点存储的不是行数据，而是对应行的主键值(id)。

                               [      Lee | Rose      ]
                                        |
                   /--------------------|--------------------\
                  /                     |                      \
        [ Geek | Jack ]         [ Lily | Oil ]         [ Ruby | Xint ]
               |                      |                      |
      /--------|--------\      /-------|--------\      /-------|--------\
     /         |         \    /        |         \    /        |         \
["Arm","Dawn"]["Geek","Hero"]["Jack","Kit"]["Lee","Lem"]["Lily","Mina"]["Oil","Pine"]["Rose","Roxy"]["Ruby","Tim"]["Xint","Zoom"]
     |           |           |          |           |           |           |          |           |
  [10,15]     [26,27]     [25,5]     [80,28]     [90,72]     [45,21]     [11,30]    [8,14]      [60,12]


==================================================================================
                                    查询流程总结
==================================================================================

1.  **使用聚集索引查询 (如 WHERE id = 25):**
    * 直接在聚集索引树中进行搜索，找到键值为 25 的叶子节点。
    * 从该叶子节点中直接读取完整的行数据 `(25, 'Jack', '男')`。
    * 过程高效，只需一次索引查找。

2.  **使用二级索引查询 (如 WHERE name = 'Jack'):**
    * 先在 `name` 字段的二级索引树中搜索，找到键值为 'Jack' 的叶子节点。
    * 从该叶子节点中读取到存储的主键值 `25`。
    * 拿到主键值 `25` 后，再回到**聚集索引树**中进行一次查找。
    * 在聚集索引中找到键值为 25 的叶子节点，并读取完整的行数据。
    * 这个“先查二级索引，再回聚集索引查数据”的过程，被称为“**回表**”(Index Lookup)。

 ==================================================================================
          “回表查询”详解 (以 `select * from user where name = 'Arm'` 为例)
==================================================================================
当数据库执行 select * from user where name = 'Arm' 这条语句时，它会按照下图所示的“回表查询”路径来查找数据：

          [ SQL查询 ]
select * from user where name = 'Arm';
             |
             V
------------------------------------------------------------------------------------
步骤 1: 搜索 name 字段的“二级索引”
------------------------------------------------------------------------------------
# 数据库首先利用“二级索引”来定位 `name = 'Arm'` 的记录。
# 它会从二级索引的根节点 [Lee|Rose] 开始，最终找到包含 'Arm' 的叶节点 ["Arm","Dawn"]。

             ["Arm","Dawn"]  <-- 在二级索引的叶节点中找到 'Arm'
                  |
             [10,15]       <-- 读取与 'Arm' 关联的值，这个值是主键 id = 10
                  |
                  +----------------------------------------------+
                  |            (拿到主键值，准备“回表”)            |
                  V                                              V
------------------------------------------------------------------------------------
步骤 2: “回表”-- 使用上一步获得的主键ID，去搜索“聚集索引”
------------------------------------------------------------------------------------
# 因为二级索引中只有 name 和 id，但查询需要的是 `*` (所有字段，如 gender)，
# 所以数据库必须“回到”聚集索引中去查找完整的行数据。

                [     15 | 30      ]  <-- 从聚集索引的根节点开始，搜索 id = 10
                       |
                 /----------------...
                /
          [ 10 | 12 ]
              |
        /-----|-----\
       /      |      \
     [5,8] [10,11] [12,14]             <-- 在聚集索引的叶节点中找到 id = 10
             |
   (读取完整的行数据)
             |
             V
------------------------------------------------------------------------------------
步骤 3: 返回最终结果
------------------------------------------------------------------------------------
          (10, 'Arm', '女')

 总结
回表查询 (Index Lookup) 是指这样一种查询过程：

先通过二级索引找到匹配的记录，并从中获取到主键ID。

再使用这个主键ID，回到聚集索引中进行另一次查找。

最终在聚集索引的叶子节点中，获取到完整的行数据。


# 🗂️ MySQL 索引基础学习笔记

---

## 一、索引的优缺点

- **优势**：提高数据检索效率，降低数据库 IO 成本；通过索引列排序，降低排序成本和 CPU 消耗。
- **劣势**：索引占用空间；提高查询效率的同时，降低了表的更新速度（INSERT、UPDATE、DELETE 时效率降低）。

---

## 二、常见索引结构

- **B+Tree 索引**：最常见，绝大多数引擎支持，适合范围查询和排序。
- **Hash 索引**：底层为哈希表，只支持精确匹配，不支持范围查询。
- **R-tree（空间索引）**：主要用于地理空间数据，MyISAM 支持，使用较少。
- **Full-text（全文索引）**：倒排索引，适合文本关键词检索，类似 Lucene/Solr/ES。

---

## 三、各存储引擎索引支持情况

| 索引类型   | InnoDB | MyISAM | Memory  |
|------------|--------|--------|---------|
| B+Tree     | 支持   | 支持   | 支持    |
| Hash       | 不支持 | 不支持 | 支持    |
| R-tree     | 不支持 | 支持   | 不支持  |
| Full-text  | 5.6+支持 | 支持 | 不支持  |

---

## 四、索引结构原理

### 1. 二叉树与红黑树

- 顺序插入易退化为链表，查询性能差。
- 层级深，检索速度慢。

### 2. B-Tree（多路平衡查找树）

- 每个节点存储多个 key 和指针，减少树高度，提高检索效率。
- 非叶子节点和叶子节点都存数据。
- [ 图例 (Legend) ]
​```
- [K(D)]        : 代表一个节点页(Page)。
                  - K 是“键值”(Key)。
                  - (D) 代表与该键值关联的“数据”(Data)或数据指针。
                  - B-树中，数据(D)与键值(K)在所有层级的节点中都成对出现。
- / | \         : 代表“指针”(Pointer)，指向子节点页。

---------------------------------- 层级 1: 根页 (Root Page) ---------------------------------

                                    [ 34(D) ]
                                         |
                            /---------------------------\
                           /                             \

---------------------- 层级 2: 内部页 (Internal Pages) -------------------------

                [ 16(D) ]                         [ 62(D) | 90(D) ]
                     |                                   |
            /----------------\                      /-----|-----\
           /                  \                    /      |      \

---------------------- 层级 3: 叶节点页 (Leaf Pages) -------------------------

     [6(D)|12(D)]      [18(D)|29(D)]      [38(D)|56(D)] [67(D)|87(D)] [94(D)|98(D)]

     (注意：叶节点之间没有互相连接的指针)
​```

### 3. B+Tree

- 非叶子节点只存 key 和指针，所有数据都在叶子节点。
- 叶子节点通过指针形成单向链表，便于范围查询。
- MySQL 在 B+Tree 基础上优化，叶节点间有顺序指针，区间访问性能更高。


| 要点              | 内容                           |
| --------------- | ---------------------------- |
| **页（Page）**     | InnoDB 存储的基本单位，默认 16KB。      |
| **键（Key）**      | 索引用于排序的字段。                   |
| **数据（Data）**    | 叶子节点存储内容，主键索引为整行数据，二级索引为主键值。 |
| **指针（Pointer）** | 页与页、节点与节点的连接纽带，确保树能快速导航。     |
| **非叶子节点**       | 只存 Key + 指针。                 |
| **叶子节点**        | 存 Key + Data + 相邻页指针。        |

---

## 五、B+Tree 结构示意

- 根页、索引页、叶节点页分层组织。
- 叶节点存储所有数据，并通过指针形成链表，便于范围扫描。
​```
- [ ... ]       : 代表一个完整的“页”(Page)或“块”(Block)。
- / | \         : 代表“指针”(Pointer)，从一个索引页指向下一层的页。
- [P| K1 |P| K2|P] : 索引页的内部结构示意。
                  - K1, K2 是“键值”(Key)，用作索引。
                  - P 是“指针”(Pointer)，指向子节点页。
- [K1|D]<->[K2|D] : 叶节点页(数据页)的内部结构示意。
                  - K1, K2 是“键值”(Key)。
                  - D 代表与键值关联的“数据”(Data)。
                  - <-> 代表叶节点页之间的双向指针。

---------------------------------- 层级 1: 根页 (Root Page) ---------------------------------
                                     (指针 P0) (指针 P1) (指针 P2)
                                        |       |        |
                                      [ 38 | 67 ]
                                            |
                       /--------------------|--------------------\
                      /                     |                      \
                     P0                    P1                     P2

---------------------- 层级 2: 索引页 (Index Pages) -------------------------

            [ 16 | 29 ]               [ 55 | 58 ]                [ 90 | 94 ]
                  |                         |                          |
         /--------|--------\         /------|-------\          /-------|--------\
        /         |         \       /        |        \        /        |         \

---------- 层级 3: 叶节点页 (Leaf Pages) - 包含键值(Key)和数据(Data) -----------

[6|D]<->[16|D]<->[29|D]<->[38|D]<->[55|D]<->[58|D]<->[67|D]<->[90|D]<->[94|D]
 ^                                                                         |
 |________________________(所有数据页通过指针形成一个双向链表)_______________________|
 ​```
- 相对于B-Tree区别：
 ①．所有的数据都会出现在叶子节点
 ②．叶子节点形成一个单向链表

 MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。

- 为什么InnoDB存储引擎选择使用B+tree索引结构？
1.相对于二叉树，层级更少，搜索效率高；
2.对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；
相对Hash索引，B+tree支持范围匹配及排序操作；

---

## 六、索引的组成

| 组成部分 | 层级   | 内容           | 存储位置 | 大小         |
|----------|--------|----------------|----------|--------------|
| 页（Page） | 物理层 | 存储多个索引记录 | 磁盘     | 16 KB        |
| 键值（Key） | 逻辑层 | 用于排序和定位   | 记录区   | 几字节~几十字节 |
| 数据（Data） | 逻辑层 | 记录实际值或主键 | 叶节点   | 依字段类型   |
| 指针（Pointer） | 结构层 | 指向页或相邻记录 | 非叶/叶页 | ~6字节      |

- 非叶节点只存 Key+指针，叶节点存 Key+Data+相邻页指针。

---

## 七、索引分类

| 分类     | 含义                       | 特点           | 关键字    |
|----------|----------------------------|----------------|-----------|
| 主键索引 | 针对主键创建，唯一且自动   | 只能有一个     | PRIMARY   |
| 唯一索引 | 保证列值唯一               | 可有多个       | UNIQUE    |
| 常规索引 | 快速定位数据               | 可有多个       |           |
| 全文索引 | 文本关键词检索             | 可有多个       | FULLTEXT  |

---

## 八、InnoDB 索引存储形式

| 分类         | 含义                                         | 特点           |
|--------------|----------------------------------------------|----------------|
| 聚集索引     | 数据与索引存一起，叶节点存整行数据           | 必须有且唯一   |
| 二级索引     | 索引与数据分开，叶节点存主键值               | 可有多个       |

**聚集索引选取规则：**
- 有主键则主键为聚集索引；
- 无主键则第一个唯一索引为聚集索引；
- 都没有则自动生成 rowid 作为隐藏聚集索引。

---

## 九、聚集索引与二级索引结构示意

- **聚集索引**：叶节点存整行数据，索引与数据“聚集”在一起。
- **二级索引**：叶节点存主键值，通过主键值再去聚集索引查找整行数据（回表）。

​```
==================================================================================
  InnoDB 聚集索引 (Clustered Index) 与 二级索引 (Secondary Index) 结构示意图
==================================================================================

---------------------------------- 1. 原始数据表 ---------------------------------
(代表实际存储在磁盘上的数据行)
+----+-------+--------+
| id | name  | gender |
+----+-------+--------+
| 5  | Kit   | 男     |
| 8  | Ruby  | 女     |
| 10 | Arm   | 女     |
| 11 | Rose  | 女     |
...  ...      ...

----------------------- 2. 聚集索引 (Clustered Index) - 基于主键 id -----------------------
# 叶子节点存储了完整的行数据。
                     [     15 | 30      ]
                            |
           /----------------|----------------\
          /                 |                  \
    [ 10 | 12 ]       [ 25 | 27 ]         [ 60 | 80 ]
        |                  |                    |
  /-----|-----\      /-----|-----\        /-----|-----\
...    ...     ...
[5,8] [10,11] [12,14] ...
 |     |       |
(整行) (整行) (整行) ...
(数据) (数据) (数据)


-------------------------- 3. 二级索引 (Secondary Index) - 基于 name 字段 --------------------------
# 叶子节点存储的是对应行的主键值(id)。
                               [      Lee | Rose      ]
                                        |
                   /--------------------|--------------------\
                  /                     |                      \
        [ Geek | Jack ]         [ Lily | Oil ]         [ Ruby | Xint ]
               |                      |                      |
      /--------|--------\      /-------|--------\      /-------|--------\
     /         |         \    /        |         \    /        |         \
["Arm","Dawn"]["Geek","Hero"] ...
     |           |
  [10,15]     [26,27]    ...
​```

1.  **使用聚集索引查询 (如 WHERE id = 25):**
    * 直接在聚集索引树中进行搜索，找到键值为 25 的叶子节点。
    * 从该叶子节点中直接读取完整的行数据 `(25, 'Jack', '男')`。
    * 过程高效，只需一次索引查找。

2.  **使用二级索引查询 (如 WHERE name = 'Jack'):**
    * 先在 `name` 字段的二级索引树中搜索，找到键值为 'Jack' 的叶子节点。
    * 从该叶子节点中读取到存储的主键值 `25`。
    * 拿到主键值 `25` 后，再回到**聚集索引树**中进行一次查找。
    * 在聚集索引中找到键值为 25 的叶子节点，并读取完整的行数据。
    * 这个“先查二级索引，再回聚集索引查数据”的过程，被称为“**回表**”(Index Lookup)。

---

## 十、回表查询流程

1. 用二级索引定位记录，获得主键值。
2. 用主键值回到聚集索引查找完整行数据。
3. 返回最终结果。
​```
==================================================================================
          “回表查询”详解 (以 `select * from user where name = 'Arm'` 为例)
==================================================================================
          [ SQL查询 ]
select * from user where name = 'Arm';
             |
             V
------------------------------------------------------------------------------------
步骤 1: 搜索 name 字段的“二级索引”
------------------------------------------------------------------------------------
# 数据库首先利用“二级索引”来定位 `name = 'Arm'` 的记录。
# 它会从二级索引的根节点 [Lee|Rose] 开始，最终找到包含 'Arm' 的叶节点 ["Arm","Dawn"]。

             ["Arm","Dawn"]  <-- 在二级索引的叶节点中找到 'Arm'
                  |
             [10,15]       <-- 读取与 'Arm' 关联的值，这个值是主键 id = 10
                  |
                  +----------------------------------------------+
                  |            (拿到主键值，准备“回表”)            |
                  V                                              V
------------------------------------------------------------------------------------
步骤 2: “回表”-- 使用上一步获得的主键ID，去搜索“聚集索引”
------------------------------------------------------------------------------------
# 因为二级索引中只有 name 和 id，但查询需要的是 `*` (所有字段，如 gender)，
# 所以数据库必须“回到”聚集索引中去查找完整的行数据。

                [     15 | 30      ]  <-- 从聚集索引的根节点开始，搜索 id = 10
                       |
                 /----------------...
                /
          [ 10 | 12 ]
              |
        /-----|-----\
       /      |      \
     [5,8] [10,11] [12,14]             <-- 在聚集索引的叶节点中找到 id = 10
             |
   (读取完整的行数据)
             |
             V
------------------------------------------------------------------------------------
步骤 3: 返回最终结果
------------------------------------------------------------------------------------
          (10, 'Arm', '女')
​```
## 总结：回表查询（Index Lookup）

回表查询（Index Lookup）是指这样一种查询过程：

1. **先通过二级索引找到匹配的记录，并从中获取到主键ID。**
2. **再使用这个主键ID，回到聚集索引中进行另一次查找。**
3. **最终在聚集索引的叶子节点中，获取到完整的行数据。**

这种查询方式常见于 InnoDB 存储引擎的二级索引查询，能够兼顾索引检索效率和数据完整性，但会增加一次“回表”操作的成本。
---

## 十一、总结

- B+Tree 是 MySQL 索引的主流结构，支持高效范围查询和排序。
- InnoDB 聚集索引存整行数据，二级索引存主键值，涉及“回表”操作。
- 合理设计索引能显著提升查询性能，但会影响写入和占用空间。

---