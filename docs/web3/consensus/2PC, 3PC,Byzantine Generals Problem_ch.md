# 分布式事务一致性：2PC、3PC 与拜占庭将军问题

## 一、2PC（Two-Phase Commit，两阶段提交）

### 1. 基本流程

**阶段一：投票 (Voting)**

1. 协调者 → 所有参与者：发送 `CanCommit` 请求  
2. 参与者：
   - 如果准备好执行事务 → 回复 `Yes`
   - 如果不能执行 → 回复 `No`
3. 协调者：
   - 如果所有人回复 `Yes` → 进入阶段二
   - 如果有任何 `No` 或超时 → 向所有参与者发送 `Abort`

**阶段二：提交 (Commit)**

1. 如果阶段一所有人都同意：
   - 协调者 → 所有参与者：发送 `DoCommit`
   - 参与者：执行事务提交，并回复 `Ack`
2. 协调者：
   - 收到所有 `Ack` → 事务成功
   - 如果超时或收到错误 → 发送 `Abort`
   - 参与者收到 `Abort` → 回滚事务

### 2. 特点

- ✅ 保证原子性：要么全部提交，要么全部回滚  
- ❌ 缺陷：无法解决网络分区导致的阻塞问题，协调者单点故障风险大

### 3. 脑裂问题举例

假设有一个协调者 C，两个参与者 A、B：

1. C 向 A、B 发送 Prepare 请求  
2. A、B 都返回 Vote-commit  
3. 在 C 发送 Commit 之前，网络发生分区：
   - A 收到 Commit，提交事务  
   - B 没收到，阻塞等待  

**结果：**

- A 提交  
- B 阻塞甚至回滚  
- 系统出现不一致

### 4. 风险

- 数据不一致  
- 系统阻塞  
- 可能出现并发冲突（双写）

---

## 二、3PC（Three-Phase Commit，三阶段提交）

### 1. 改进点

在 2PC 的基础上引入 **预提交阶段（PreCommit）**，并增加超时机制，减少阻塞。

**阶段一：CanCommit**

- 协调者询问参与者是否能提交  
- 参与者回复 Yes 或 No  
- 如果超时 → 参与者自动中止事务

**阶段二：PreCommit**

- 如果所有参与者回复 Yes：
  - 协调者发送 PreCommit  
  - 参与者写入 Undo/Redo 日志，回复 Yes，并启动超时  
- 如果超时未收到最终指令：参与者可直接提交，避免阻塞

**阶段三：DoCommit**

- 协调者发送 DoCommit  
- 参与者执行提交并回复 Ack  
- 协调者确认事务完成

### 2. 特点

- ✅ 引入超时机制，避免阻塞  
- ✅ 状态一致性比 2PC 更强  
- ❌ 网络分区或拜占庭错误时，依然可能不一致  
- ❌ 增加一轮通信，性能开销更大

### 3. 3PC 失效场景举例

系统：协调者 C，参与者 A、B、X

1. 阶段一：所有人回复 Yes  
2. 阶段二：C 发送 PreCommit，A、B 收到并写日志，X 因网络延迟未收到  
3. 阶三前，协调者 C 崩溃  

**结果：**

- A、B：超时后根据协议直接提交  
- X：未收到 PreCommit，选择回滚  

→ 系统出现不一致

---

## 三、拜占庭将军问题

### 1. 问题定义

在分布式系统中，某些节点可能是恶意或失效。如何保证即使存在“叛徒”，忠诚节点依然能达成一致，是拜占庭将军问题的核心。

### 2. 示例场景（9 位将军，1 位叛徒）

- 4 位忠诚将军投票 **进攻**  
- 4 位忠诚将军投票 **撤退**  
- 1 位叛徒（恶意节点）→ 向不同阵营散布相互矛盾的信息  

**结果：**

- 进攻派看到 5 票进攻 → 决定进攻  
- 撤退派看到 5 票撤退 → 决定撤退  

→ 系统一致性被破坏

### 3. 与 2PC / 3PC 的关系

- 2PC：会阻塞，存在单点故障  
- 3PC：减少阻塞，但依然无法解决拜占庭错误  
- 拜占庭场景下：需要更强的一致性算法（如 PBFT、Raft、Paxos）

---

## 四、总结

- **2PC**：保证原子性，但可能阻塞，存在单点问题  
- **3PC**：通过预提交 + 超时机制减少阻塞，但仍无法应对拜占庭问题  
- **拜占庭将军问题**：说明了在恶意节点存在时，2PC/3PC 都无法保证一致，需要更健壮的共识算法
